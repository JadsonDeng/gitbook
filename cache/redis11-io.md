# 线程IO模型

**Redis是个单线程程序！**  

也许你会怀疑告并发的Redis中间件怎么可能是单线程。很抱歉，它就是单线程。除了Redis之外，NodeJs也是单线程，Nginx也是单线程，但是他们都是服务器高性能的典范。

**Redis单线程为什么还能这么快**

因为它所有的数据都在内存中，所有的运算都是内存级别的运算。正因为Redis是单线程，所以要小心使用Redis指令，对于那些时间复杂度为O(N)级别的指令，一定要小心谨慎使用，一不小心就可能导致Redis服务卡顿。

**Redis单线程如何处理那么多的并发客户端链接？**

多路复用

## 非阻塞IO
---
当我们调用套接字的读写方法，默认他们是阻塞的，比如read方法要传进去一个参数n，表示最多读取这么多字节后再返回，如果一个字节都没有，那么线程就会卡在那里，直到新的数据到来或者链接关闭了，read方法才可以返回，线程才能继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经满了，write方法就会阻塞，直到缓冲区中有空闲空间挪出来。

![PNG](images/redis11-1.png)

非阻塞IO在套接字对象上提供了一个选项Non_Blocking，当这个选项打开时，读写方法不会阻塞，而是能读多少就读多少，能写多少就写多少。能读多少取决于内核为套接字分配的读缓冲区内部的数据字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。

## 事件轮询（多路复用）
---
非阻塞IO有个问题，那就是线程要读数据，结果读了一部分就返回了，线程如何知道何时才能继续读。也就是当数据到来时，线程如何得到通知。写也是一样，如果缓冲区满了，写不完，剩下的数据何时才能继续写，线程也应该得到通知。

![PNG](images/redis11-2.png)

时间轮询API就是用来解决这个问题的，最简单的事件轮询API是select函数，它是操作系统提供给用户程序的API。现在操作系统的多路复用API已经不再使用select系统调用，而是改用epoll(linux)和